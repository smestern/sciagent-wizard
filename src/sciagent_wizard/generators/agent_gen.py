"""
Generate ``agent.py`` — the BaseScientificAgent subclass for the new domain.
"""

from __future__ import annotations

from sciagent_wizard.models import WizardState


def generate_agent_source(state: WizardState) -> str:
    """Return Python source for the generated agent's ``agent.py``."""

    class_name = _to_class_name(state.agent_name)
    config_const = state.agent_name.upper().replace("-", "_").replace(" ", "_") + "_CONFIG"
    module_slug = state.agent_name.replace("-", "_").replace(" ", "_")

    # Extra libraries for execution environment
    env_imports: list[str] = []
    env_dict_items: list[str] = []
    for pkg in state.confirmed_packages:
        mod = pkg.pip_name.replace("-", "_").lower()
        if mod:
            env_imports.append(f"            import {mod}")
            env_dict_items.append(f'            env["{mod}"] = {mod}')

    env_try_block = ""
    if env_imports:
        imports_str = "\n".join(env_imports)
        dict_str = "\n".join(env_dict_items)
        env_try_block = f"""\
        try:
{imports_str}
{dict_str}
        except ImportError:
            pass"""
    else:
        env_try_block = "        pass"

    # Script imports
    script_imports = [pkg.pip_name.replace("-", "_") for pkg in state.confirmed_packages if pkg.pip_name]
    script_list = ", ".join(f'"{s}"' for s in script_imports)

    source = f'''\
"""
{state.agent_display_name} — Domain-specific scientific agent.

Auto-generated by the sciagent self-assembly wizard.

Usage::

    python -m {module_slug}
    python -m {module_slug} --web
"""

from __future__ import annotations

from typing import Any, Dict, List

from sciagent.base_agent import BaseScientificAgent
from sciagent.prompts.base_messages import build_system_message
from sciagent.tools.code_tools import execute_code, validate_code
from sciagent.tools.registry import collect_tools

from .config import {config_const}
from .domain_prompt import DOMAIN_EXPERTISE


class {class_name}(BaseScientificAgent):
    """{state.agent_description}"""

    def __init__(self, **kwargs):
        super().__init__({config_const}, **kwargs)

    # -- Required: register tools -------------------------------------------

    def _load_tools(self) -> List:
        # Core code execution tools
        tools = [
            self._create_tool(
                name="execute_code",
                description=(
                    "Execute Python code for scientific analysis. "
                    "All domain libraries are pre-imported in the sandbox."
                ),
                handler=execute_code,
                parameters={{
                    "type": "object",
                    "properties": {{
                        "code": {{
                            "type": "string",
                            "description": "Python code to execute",
                        }},
                    }},
                    "required": ["code"],
                }},
            ),
            self._create_tool(
                name="validate_code",
                description="Check Python code for syntax errors and safety issues.",
                handler=validate_code,
                parameters={{
                    "type": "object",
                    "properties": {{
                        "code": {{
                            "type": "string",
                            "description": "Python code to validate",
                        }},
                    }},
                    "required": ["code"],
                }},
            ),
        ]

        # Domain-specific tools (auto-discovered from tools module)
        try:
            from . import tools as domain_tools_module
            for info in collect_tools(domain_tools_module):
                tools.append(self._create_tool(*info))
        except ImportError:
            pass

        return tools

    # -- System message with domain expertise --------------------------------

    def _get_system_message(self) -> str:
        return build_system_message(DOMAIN_EXPERTISE)

    # -- Pre-import domain libraries into the sandbox ------------------------

    def _get_execution_environment(self) -> Dict[str, Any]:
        env: Dict[str, Any] = {{}}
{env_try_block}
        return env

    # -- Extra imports for reproducible scripts ------------------------------

    def _get_script_imports(self) -> List[str]:
        return [{script_list}]


# ── Factory ─────────────────────────────────────────────────────────────

def create_agent(**kwargs) -> {class_name}:
    """Factory function matching the sciagent convention."""
    return {class_name}(**kwargs)
'''
    return source


def _to_class_name(slug: str) -> str:
    """Convert ``"my-cool-agent"`` → ``"MyCoolAgent"``."""
    return "".join(word.capitalize() for word in slug.replace("_", "-").split("-")) + "Agent"
