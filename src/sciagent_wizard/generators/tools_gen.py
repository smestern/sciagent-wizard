"""
Generate ``tools.py`` — domain-specific tool wrappers for the new agent.

For each confirmed package, generates thin ``@tool``-decorated wrappers
that expose the library's key functionality to the agent.
"""

from __future__ import annotations

from sciagent_wizard.models import PackageCandidate, WizardState


def generate_tools_source(state: WizardState) -> str:
    """Return Python source for ``tools.py`` in the generated project.

    Each confirmed package gets:
    - An import (guarded by try/except)
    - One wrapper tool that delegates to that library
    - A summary tool listing all available domain tools

    The generated tools module uses the ``@tool`` decorator from
    ``sciagent.tools.registry``.
    """
    imports_block = _build_imports(state.confirmed_packages)
    tool_functions = _build_tool_functions(state.confirmed_packages)

    source = f'''\
"""
Domain-specific tools for {state.agent_display_name}.

Auto-generated by the sciagent self-assembly wizard.
Each tool wraps a domain library so the agent can use them naturally.
"""

from __future__ import annotations

import json
from typing import Any, Dict

from sciagent.tools.registry import tool

{imports_block}


# ── Domain tool wrappers ────────────────────────────────────────────────

{tool_functions}

# ── Discovery: list available domain tools ──────────────────────────────

@tool(
    name="list_domain_tools",
    description=(
        "List the domain-specific analysis tools available in this agent. "
        "Call this first to understand what specialised analyses you can perform."
    ),
)
def list_domain_tools() -> str:
    """Return a summary of available domain tools."""
    tools = [
{_available_tools_entries(state.confirmed_packages)}
    ]
    # Only include tools whose library loaded successfully
    available = [t for t in tools if t.get("available")]
    return json.dumps({{"tools": available, "total": len(available)}}, indent=2)
'''
    return source


# ── Internal helpers ────────────────────────────────────────────────────


def _build_imports(packages: list[PackageCandidate]) -> str:
    """Build guarded import block."""
    lines: list[str] = []
    for pkg in packages:
        mod = _module_name(pkg)
        if not mod:
            continue
        var = _flag_var(pkg)
        lines.append(f"try:\n    import {mod}\n    {var} = True\nexcept ImportError:\n    {var} = False")
    return "\n\n".join(lines) if lines else "# No domain packages configured"


def _build_tool_functions(packages: list[PackageCandidate]) -> str:
    """Generate a wrapper tool for each package."""
    blocks: list[str] = []
    for pkg in packages:
        mod = _module_name(pkg)
        if not mod:
            continue
        fn_name = f"run_{_safe_name(pkg)}"
        desc = pkg.description[:200] if pkg.description else f"Run analysis using {pkg.name}"

        block = f'''\
@tool(
    name="{fn_name}",
    description=(
        "{_esc(desc)}. "
        "Pass Python code that uses the {pkg.name} library. "
        "The library is already imported as `{mod}`."
    ),
    parameters={{
        "type": "object",
        "properties": {{
            "code": {{
                "type": "string",
                "description": "Python code using {pkg.name}",
            }},
        }},
        "required": ["code"],
    }},
)
def {fn_name}(code: str) -> str:
    """Execute code with {pkg.name} available."""
    if not {_flag_var(pkg)}:
        return json.dumps({{"error": "{pkg.name} is not installed. Run: {pkg.install_command}"}})
    # Delegate to the shared execute_code infrastructure
    from sciagent.tools.code_tools import execute_code
    return execute_code(code=code)
'''
        blocks.append(block)

    return "\n\n".join(blocks) if blocks else "# No domain tool wrappers generated"


def _available_tools_entries(packages: list[PackageCandidate]) -> str:
    """Build the list literal entries for ``list_domain_tools``."""
    entries: list[str] = []
    for pkg in packages:
        mod = _module_name(pkg)
        if not mod:
            continue
        fn = f"run_{_safe_name(pkg)}"
        desc = _esc(pkg.description[:120]) if pkg.description else pkg.name
        entries.append(
            f'        {{"name": "{fn}", "library": "{pkg.name}", '
            f'"description": "{desc}", "available": {_flag_var(pkg)}}},'
        )
    return "\n".join(entries)


def _module_name(pkg: PackageCandidate) -> str:
    """Guess the importable module name from a package."""
    raw = pkg.pip_name or pkg.name
    return raw.replace("-", "_").lower()


def _safe_name(pkg: PackageCandidate) -> str:
    """Create a safe Python identifier from a package name."""
    return _module_name(pkg).replace(".", "_")


def _flag_var(pkg: PackageCandidate) -> str:
    """Boolean flag variable name for import success."""
    return f"_HAS_{_safe_name(pkg).upper()}"


def _esc(s: str) -> str:
    return s.replace("\\", "\\\\").replace('"', '\\"').replace("\n", " ")
