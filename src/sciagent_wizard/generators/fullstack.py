"""
Project generator — orchestrate all code-gen into a runnable agent project.

Produces a directory structure like::

    <output>/<agent_name>/
        __init__.py
        __main__.py
        agent.py
        config.py
        tools.py
        domain_prompt.py
        requirements.txt
        README.md
        sample_data/          (if example data provided)
"""

from __future__ import annotations

import logging
import shutil
from pathlib import Path
from typing import Optional

from sciagent_wizard.models import OutputMode, WizardState
from .config_gen import generate_config_source
from .copilot import generate_copilot_project
from .docs_gen import write_docs
from .markdown import generate_markdown_project
from .prompt_gen import generate_prompt_source
from .tools_gen import generate_tools_source
from .agent_gen import generate_agent_source
from sciagent_wizard.rendering import render_docs as render_doc_templates

logger = logging.getLogger(__name__)


def generate_project(
    state: WizardState,
    output_dir: Optional[str | Path] = None,
) -> Path:
    """Generate a complete agent project from wizard state.

    Args:
        state: Populated ``WizardState`` from the wizard conversation.
        output_dir: Parent directory for the project. Defaults to CWD.

    Returns:
        Path to the generated project directory.
    """
    base = Path(output_dir) if output_dir else Path.cwd()
    slug = state.agent_name.replace(" ", "_").replace("-", "_")
    project_dir = base / slug
    project_dir.mkdir(parents=True, exist_ok=True)

    logger.info("Generating agent project in %s (mode=%s)", project_dir, state.output_mode)

    # ── Dispatch by output mode ─────────────────────────────────────
    if state.output_mode == OutputMode.COPILOT_AGENT:
        return generate_copilot_project(state, project_dir)
    if state.output_mode == OutputMode.MARKDOWN:
        return generate_markdown_project(state, project_dir)

    # ── FULLSTACK (default) ─────────────────────────────────────────

    # ── Core modules ────────────────────────────────────────────────
    _write(project_dir / "__init__.py", _init_source(state))
    _write(project_dir / "__main__.py", _main_source(state))
    _write(project_dir / "config.py", generate_config_source(state))
    _write(project_dir / "domain_prompt.py", generate_prompt_source(state))
    _write(project_dir / "tools.py", generate_tools_source(state))
    _write(project_dir / "agent.py", generate_agent_source(state))

    # ── requirements.txt ────────────────────────────────────────────
    _write(project_dir / "requirements.txt", _requirements(state))

    # ── README ──────────────────────────────────────────────────────
    _write(project_dir / "README.md", _readme(state))

    # ── Copy example data ───────────────────────────────────────────
    if state.example_files:
        sample_dir = project_dir / "sample_data"
        sample_dir.mkdir(exist_ok=True)
        for fi in state.example_files:
            src = Path(fi.path)
            if src.exists():
                try:
                    shutil.copy2(src, sample_dir / src.name)
                except Exception as exc:
                    logger.warning("Could not copy sample %s: %s", src, exc)

    # ── Documentation templates ──────────────────────────────────────
    docs_dir = project_dir / "docs"
    render_doc_templates(state, docs_dir)

    # ── Package docs (auto-fetched) ────────────────────────────────
    if state.package_docs:
        write_docs(state, docs_dir)

    state.project_dir = str(project_dir)
    logger.info("Agent project generated: %s", project_dir)
    return project_dir


# ── Template sources ────────────────────────────────────────────────────


def _init_source(state: WizardState) -> str:
    class_name = _to_class_name(state.agent_name)
    return f'''\
"""
{state.agent_display_name}

Auto-generated by the sciagent self-assembly wizard.
"""

from .agent import {class_name}, create_agent

__all__ = ["{class_name}", "create_agent"]
'''


def _main_source(state: WizardState) -> str:
    config_const = state.agent_name.upper().replace("-", "_").replace(" ", "_") + "_CONFIG"
    return f'''\
"""
Entry point: ``python -m {state.agent_name.replace("-", "_")}``
"""

import sys

from .agent import create_agent
from .config import {config_const}


def main():
    if "--web" in sys.argv:
        from sciagent.web.app import create_app

        app = create_app(create_agent, {config_const})
        app.run(host="0.0.0.0", port=5000)
    else:
        from sciagent.cli import run_cli

        run_cli(create_agent, {config_const})


if __name__ == "__main__":
    main()
'''


def _requirements(state: WizardState) -> str:
    lines = ["sciagent"]
    for pkg in state.confirmed_packages:
        pname = pkg.pip_name
        if pname and pname.lower() != "sciagent":
            lines.append(pname)
    return "\n".join(sorted(set(lines))) + "\n"


def _readme(state: WizardState) -> str:
    slug = state.agent_name.replace("-", "_")
    pkgs = "\n".join(f"- {p.name}: {p.description[:80]}" for p in state.confirmed_packages)
    return f"""\
# {state.agent_display_name}

{state.agent_description}

> Auto-generated by the **sciagent self-assembly wizard**.

## Quick Start

```bash
# Install dependencies
pip install -r requirements.txt

# Run in CLI mode
python -m {slug}

# Run with web UI
python -m {slug} --web
```

## Domain Packages

{pkgs or "No additional packages configured."}

## Customisation

- **Domain prompt**: Edit `domain_prompt.py` to refine the agent's expertise.
- **Tools**: Edit `tools.py` to add or modify domain-specific tools.
- **Config**: Edit `config.py` to change file types, suggestion chips, guardrails.
- **Agent logic**: Edit `agent.py` to override additional hooks.
"""


def _to_class_name(slug: str) -> str:
    return "".join(word.capitalize() for word in slug.replace("_", "-").split("-")) + "Agent"


def _write(path: Path, content: str) -> None:
    path.write_text(content, encoding="utf-8")
    logger.debug("Wrote %s", path)
