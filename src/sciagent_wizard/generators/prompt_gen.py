"""
Generate the domain expertise prompt section for a new agent.
"""

from __future__ import annotations

from sciagent_wizard.models import WizardState


def generate_prompt_source(state: WizardState) -> str:
    """Return Python source for ``domain_prompt.py``.

    The module exposes a ``DOMAIN_EXPERTISE`` string constant that the
    generated agent inserts into ``build_system_message()``.
    """
    # Build the expertise text from wizard state
    expertise = _build_expertise_text(state)

    source = f'''\
"""
Domain expertise prompt for {state.agent_display_name}.

Auto-generated by the sciagent self-assembly wizard.
Edit this file to refine the agent's domain knowledge.
"""

DOMAIN_EXPERTISE = """
{_esc_triple(expertise)}
"""
'''
    return source


def _build_expertise_text(state: WizardState) -> str:
    """Compose domain expertise from wizard state fields."""
    sections: list[str] = []

    # Header
    sections.append(f"## {state.agent_display_name} — Domain Expertise")

    # Domain description
    if state.domain_description:
        sections.append(f"### Domain\n{state.domain_description}")

    # Research goals
    if state.research_goals:
        goals = "\n".join(f"- {g}" for g in state.research_goals)
        sections.append(f"### Research Goals\n{goals}")

    # Available libraries
    if state.confirmed_packages:
        libs = []
        for pkg in state.confirmed_packages:
            desc = f"  - **{pkg.name}**: {pkg.description}" if pkg.description else f"  - **{pkg.name}**"
            libs.append(desc)
        lib_text = "\n".join(libs)
        sections.append(
            f"### Available Domain Libraries\n"
            f"The following domain-specific Python packages are installed "
            f"and available for use:\n{lib_text}\n\n"
            f"Prefer these established libraries over writing custom "
            f"implementations."
        )

    # File types
    if state.accepted_file_types:
        types = ", ".join(f"`{t}`" for t in state.accepted_file_types)
        sections.append(f"### Supported File Types\n{types}")

    # Data characteristics (from example data)
    if state.example_files:
        data_hints: list[str] = []
        for fi in state.example_files:
            if fi.columns:
                cols = ", ".join(fi.columns[:20])
                data_hints.append(f"- **{fi.extension}** files with columns: {cols}")
            if fi.inferred_domain_hints:
                hints = ", ".join(fi.inferred_domain_hints)
                data_hints.append(f"  Domain patterns detected: {hints}")
        if data_hints:
            sections.append("### Typical Data Structure\n" + "\n".join(data_hints))

    # Bounds / expected ranges
    if state.bounds:
        range_items = []
        for param, (lo, hi) in state.bounds.items():
            range_items.append(f"- **{param}**: {lo} – {hi}")
        sections.append(
            "### Expected Value Ranges\n"
            "Flag values outside these ranges as potentially erroneous:\n"
            + "\n".join(range_items)
        )

    # Package documentation reference
    if state.package_docs:
        doc_lines = [
            "### Package Documentation",
            "",
            "Detailed reference documentation is available in the `docs/` "
            "directory for each installed library. Use the `read_doc` tool "
            "to access them by name:",
            "",
        ]
        for name in sorted(state.package_docs.keys()):
            doc_lines.append(f"- `{name}`")
        sections.append("\n".join(doc_lines))

    # Use any pre-generated prompt content from the LLM refinement step
    if state.domain_prompt:
        sections.append(f"### Additional Domain Knowledge\n{state.domain_prompt}")

    return "\n\n".join(sections)


def _esc_triple(text: str) -> str:
    """Escape text for embedding inside triple-quoted Python strings."""
    return text.replace("\\", "\\\\").replace('"""', '\\"\\"\\"')
